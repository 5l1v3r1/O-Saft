#! /usr/bin/perldoc 
#?
#? NAME
#?      Makefile.pod    - documentation for Makefiles in POD format
#?
#? SYNOPSYS
#?      Makefile.pod
#?      perldoc Makefile.pod
#?
#? DESCRIPTION
#?      This file conatains the internal (developer) documentation for all other
#?      Makefiles.  This is done to keep other Makefiles  as simple as possible,
#?      and just containing the user documentation.
#?
# HACKER's INFO
#
#? VERSION
#?      @(#) Makefile.pod 1.5 19/03/10 18:26:25
#?
#? AUTHOR
#?      18-nov-18 Achim Hoffmann
#?
# -----------------------------------------------------------------------------

=pod

=head2 Make:GNU

some text


=head2 Make:automatic variables

Note: macro is a synonym for variable in makefiles.

Note: macro definitions in makefiles must not be sequential!

Remember make's automatic variables:

        $@    - target (file)
        $+    - all dependencies of the target
        $^    - all dependencies of the target (without duplicates)
        $<    - first dependency of the target
        $?    - dependencies newer than the target
        $|    - "orde-only" dependencies
        $*    - matching files of the rule
        $%    - target (archive) member name (rarely used)

Use of $$ avoids evaluating $ .


=head2 Make:target name

For better readability, "speaking names"  should be used for pattern rules
and targets. It also allows to use the special pattern rule test.pattern-%
to execute a group of similar targets.


=head2 Make:target name prefix

A  unique name prefix  for targets and pattern rules should be used in all
Makefile.* to distinguish similar names. It also allows to use the pattern
rule  test.pattern-%  to execute a group of similar targets.

Following macros should then be set only for these targets, like:

    testcmd-TEMPL%:     EXE.pl      = ../program-for.TEMPL
    testcmd-TEMPL%:     TEST.init   = +quit


=head2 Make:target matching

For collecting all targets defined in a Makefile.*, following $(shell awk)
is used:

  $(shell awk -F% '($$1 ~ /^testcmd-c./){print $$1}' $(_MYSELF.some-type))

(where  testcmd-c  is an example target name). The pattern rule testcmd-c%
itself must not be matched, hence the pattern /^testcmd-c./ needs to match
$1 instead of $0 in the awk.


=head2 Make:variables and quotes

Values of variables in makefiles follow some strange rules:

  * anything right of leftmost # character is a comment and ignored
  * anything right of leftmost = character is part of the value
  * single quotes, double quotes and \ character have no special meaning
  * single quotes, double quotes and \ become meta characters depending on
    how a variable is used, in particular used with or without quotes
  * newlines in a variable are not preserved when the variable is used

For most common usage of variables, these rules are less important. But if
the variable contains descriptive texts, some care needs to be taken. This
description is about defining and using such variables with random texts.

In general it is not necessary to use quotes for variable values. However,
reading the values would be easyer and syntax highlighting in some editors
more accurate using quotes.

It is more a personal preference if quotes for variable definitions should
be used or not. The decision here is to not use quotes for definition, but
use (double) quotes for variales usage.  This also has the benefit, that a
variable is identifiable as "descriptive text" when used.

Keep in mind, that newlines to be printed must be explicitly  written in a
variable's value, $(_NL) is used for that.


=head2 Make:--dry-run

When make is called with the  -n  (--dry-run) option,  make usually simply
prints the commands to be executed instead of executing them. If a command
redirects its output to a file, the file will not be generated. But if the
command is  $(MAKE)  make will be called recursively and redirected to the
specified file. This generated file then does not contain expeced content.
Hence the generation of the file should be avoided.

The recursive make command should be printed instead of being executed.
GNU make has following documented recipe for this:

    ifeq (n,$(findstring n,$(MAKEFLAGS)))
        @echo "$(MAKE) $(MAKEFLAGS) $* > $@"
    else
        @$(MAKE) $(MAKEFLAGS) $* > $@
    endif

Unfortunately this solution has the drawback that it

  * depends on the version of GNU make (may work or not)
  * is not compatible with other make

Another possibility is to use shell's if-then-else syntax for the target's
commands. Beside the ugly definition of a shell inline script, this script
then also acts as one command in the target which makes the output hard to
read (by humans).

Hence following simplifyed if-then-else construct is used:

    @expr "$(MAKEFLAGS)" : n >/dev/null \
            && echo "$(MAKE) $(MFLAGS) -s $* > $@ 2>&1" \
            ||       $(MAKE) $(MFLAGS) -s $* > $@ 2>&1

Note that $(MAKEFLAGS) may look like:  nrR --no-print-directory


=head2 Make:Profiling

Profiling is mainly done with Perl's built-in functionality: perldebug.

There are also targets using special Perl modules  DProf and/or NYTProf to
do the profiling.

=head3 Perl packages

  * debian: libdevel-dprof-perl libdevel-nytprof-perl


=head2 Make:profile.sub

For building the function calling tree, perldebug (PERLDB_OPTS) is used.
The results can be stored in a file, see  LineInfo=  options.
Unfortunately perldebug writes output to the device directly  (for example
/dev/stdout).  It is not possible to merge output from the executed script
with that of perldebug. Following options are not helpful:

  * pager=|cat
  * LineInfo=/dev/stdout
  * noTTY=1


=head2 Make:profile.sub*_%

It should be simply possible to extend the  pattern rules  with additional
arguments. For example:  profile.sub.args   and  profile.sub.args_+cn .
These arguments are extracted in the  pattern rule itself.  This avoids to
define additional conditional rules for each pattern rule to set the macro
$(TEST.args)  with the arguments.

The simplest way to split the arguments would be:

  @$(eval _args = $(shell echo "$*" | tr '_' ' '))

but the last part of the target name needs to be removed, hence following
is used for splitting:

  @$(eval _args = $(shell echo "$*" | awk -F_ '{i=1;while(i<NF){i++;print $$i}}'))

To use the default setting if no arguments are given, following is used:

  @$(eval TEST.args = $(shell [ -n "$(_args)" ] && echo $(_args) || echo $(TEST.args) ))

=head3 profile.sub_%.log

Rules writing to logfiles cannot be named like  profile.sub.%.log  if they
should contain additional arguments like  profile.sub.%_+cn.log,  but must
be named  profile.sub.%.log_+cn  otherwise the  .log  extension becomes an
argument (see description how to split arguments above).


=head2 Make:profile.sub% target rule

This rule matches all targets, e.g.  profile.sub.entry, profile.sub.args .
It should also be possible to pass additional arguments to  $(DEV.pl). The
default argument is defined in  $(TEST.args). Other arguments to be passed
are simply added to the target, separated by  _  for example:

    profile.sub.args_+cn_--noheader

This is actually a shortcut for calling:

    profile.sub.args TEST.args="+cn --noheader"

The conditional rules split the additional arguments as follows:

  * split the rule's automatic variable  $*  by _
  * ignore the first value of the splitted arguments as it is part of the
    target name

=head3 Example for splitting: profile.sub.args_+cn_--noheader

    $*       : args_+cn_--noheader
    splitted : args +cn --noheader
    TEST.args:      +cn --noheader

This is done using (see above)

  awk -F_ '{i=1;while(i<NF){i++;print $$i}}'

=head3 Limitations

  * arguments with  _  itself cannot be used
  * when target names with or without additional arguments are used,  GNU
    Make's syntax requires separate conditional rules, hence there're:
        profile.sub.args:
        profile.sub.args_%:
  * miss-spelled targets fall back to the corresponding  basic conditional
    rules; for example  profile.sub.args-+cn  calls  profile.sub.args
  * if called from within  $(TEST.dir),  $(DEV.pl)  should be set on make
    call like:
       make profile.sub.args-+cn DEV.pl=../yeast.pl

=cut
