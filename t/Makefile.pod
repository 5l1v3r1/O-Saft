#! /usr/bin/perldoc 

=pod

=head1 NAME

Makefile.pod    - documentation for Makefiles in POD format

=head1 SYNOPSYS

    Makefile.pod
    perldoc Makefile.pod

=head1 DESCRIPTION

This file  contains the  internal (developer) documentation  for all other
Makefiles. This is done to keep other Makefiles as simple as possible, and
just containing the user (developer) documentation.

This documentation consist of following main sections:

=over

=item L</GNU Make>

=item L</O-Saft Terms>

=item L</O-Saft Makefile Syntax>

=item L</O-Saft Makefile Annotations>

=back

The sub-headers in L</O-Saft Makefile Annotations>
are referenced from all other Makefiles.

=head1 VERSION

@(#) Makefile.pod 1.25 19/11/09 20:38:08

=head1 AUTHOR

18-nov-18 Achim Hoffmann


=head1 GNU Make

Internal testing of all functionality of the project  is done using  make,
in paticular  GNU Make. In contrast to traditional make, GNU Make has more
features and behaves slightly different to traditional make.  This section
describes some GNU Make's behaviours used in the project.

=head2 GNU Make:Terms

Some words about the terms and words used in GNU Make and in this project.

    * macro  is a synonym for  variable  in Makefiles.
    * GNU Make uses  prerequisites  when targets depend on something, here
      we use dependencies.
    * GNU Make distinguishes the terms:  explicit rules,  implicit rules,
      static pattern rules. For simplicity  target  is used when  explicit
      rules  are meant and  pattern rule  is used for  static pattern rule
    * GNU Make refers to the commands executed in a target as  recipe.


=head2 GNU Make:macros

    * macro  is a synonym for  variable  in Makefiles.
    * macro definitions in makefiles must not be sequential!
    * $$ avoids evaluating $ (the macro) when reading the makefile, but it
      is evaluated when the corresponding target is executed..
    * defined using   =  deferred  definition; macro expanded when used
    * defined using  :=  immediate definition; macro expanded when defined
    * defined using ::=  immediate definition; macro expanded when defined

Note that  :=  (traditional GNU Make) is equivalent to  ::=  (POSIX). Only
:=  is used.


=head2 GNU Make:include

GNU Make's include directive doesn't understand macros, the used path must
be verbatim. To keep make's functionality (targets) maintainable, multiple
files are used.  They are all named  Makefile  or  Makefile.SUFFIX,  where
the  SUFFIX  describes the content, somehow. I.g. it should be possible to
use each of these makefiles by its own, like:

    make -f Makefile.SUFFIX target

GNU Make's include functionality, in particular when including files  sub-
directories, is difficult to use. Hence following trick is used:

    * sub-directories contains a symbolic link to . (itself)
    * Makefiles always include other files with relative paths

Example:

    ./t/ (directory)  contains:  t -> .
    ./t/Makefile.cgi  contains:  include t/Makefile

This avoids sophistcated syntax in the files itself, like:

    ifeq (t,$(findstring t,$(PWD)))
        TEST.dir = .
        # if called inside t directory,  TEST.dir  must be redifined
    endif

GNU Make also cannot manage recursive includes of the same file. This must
be checked before including, for example (using private _SID.* variable):

    ifeq (,$(_SID.test))
        -include t/Makefile
    endif

Missing the required file is silently ignored using  -include  directive.


=head2 GNU Make:important variables

Remember important variables:

    $(MAKE)         - the make command itself, in sub-make with additional
                      arguments/options (see make's dosumentation )
    $(MAKE_COMMAND) - private variable for the make command, without other
                      arguments/options as in $(MAKE)
                      SEE Make:MAKE vs. MAKE_COMMAND
    $(MFLAGS)       - contains all passed arguments/options to make
    $(MAKEFLAGS)    - same as $(MFLAGS) but omitts leading - character
    $(MAKECMDGOALS) - name of the target to be satisfied
    $(MAKEFILE)     - name of the target to be satisfied
    $(MAKEFILES)    - environment variable containing makefiles to be read
    $(MAKEFILE_LIST)- inclueded Makefiles in oder they have been read

For details use: make help.test.make


=head2 GNU Make:automatic variables

Note that macro definitions in makefiles must not be sequential!

Remember GNU Make's automatic variables:

    $@    - target (file name)
    $*    - matching files of the rule, the stem of the pattern rule
    $+    - all dependencies of the target
    $^    - all dependencies of the target (without duplicates)
    $<    - first dependency of the target
    $?    - dependencies newer than the target
    $|    - "orde-only" dependencies
    $*    - matching files of the rule
    $%    - target (archive) member name (rarely used)

Use of $$ avoids evaluating $ .


=head2 GNU Make:pattern-specific variables

Processing pattern-specific variables changed in gmake, I guess with 3.81.
Makefiles in this project rely on the behaviour of  gmake 3.81  and newer,
which applies all pattern-specific variables from all matching patterns.

If interested in the difference, read on.

Example (pre 3.81):

    VAR = default
    foo: VAR = foo
    bar: VAR = bar
    foo:
        @echo foo uses    VAR='$(VAR)'
    bar:
        @echo bar uses    VAR='$(VAR)'
    foobar:
        @echo foobar uses VAR='$(VAR)'
    other:
        @echo other uses  VAR='$(VAR)'


When calling these targets (foo, bar, foobar, other) the results are:

    foo uses    VAR='foo'
    bar uses    VAR='bar'
    foobar uses VAR='foo'
    other uses  VAR='default'

In contrast, gmake 3.81 and newer return following results:

    foo uses    VAR='default foo'
    bar uses    VAR='default bar'
    foobar uses VAR='default foo bar'
    other uses  VAR='default'

Note that the modern behaviour - applying all pattern-specific variables -
has a big performance penulty if many such variables are used. This should
not be the case in our Makefiles.


=head2 GNU Make:.SECONDEXPANSION

GNU Make's variables can be used as target, in the rules commands and also
as dependency. When used as dependency, it must be a file (or directory).

When a dependency to  another target is defined in a variable,  GNU Make's
"Secondary Expansion" must be enabled using the special target:

    .SECONDEXPANSION:

and the dependency have to be written as "escaped" variable, like:

    other = other-target
    other-target:
            do-somthing
    target: $$(other)

If the used make does not support  .SECONDEXPANSION: , the targets must be
rewritten with the real target name instead of the escaped variable.


=head2 GNU Make:MAKE vs. MAKE_COMMAND

Traditionally $(MAKE) is used for the make command itself. For convenience
t/Makefile.inc  redefines  MAKE  to contain  -f Makefile  .

When  $(MAKE)  is used in documentation (variables or texts),  make should 
be printed, usually. It is recommended to use  $(MAKE_COMMAND)  there.


=head1 O-Saft Terms


=head1 O-Saft Makefile Limitations

    Requires GNU Make > 2.0.
    Requires GNU sed for generating (target) INSTALL.sh.


=head1 O-Saft Makefile Syntax

This section describes the syntax and other conventions used in general in
all makefiles.  NOTE: this description is independent of any functionality
of the project, it just describes the used "coding syntax" in makefiles.

Makefiles  use mainly  GNU Make's built-in variables (macros) and targets.
None of them are disabled explicitly.  Therefore some behaviour may depend
on the local make configuration. SEE  Make:automatic variables  also.


=head2 O-Saft Makefile Includes

It is possible to use each Makefile independently by using GNU Make's  -f
option, for example::

    make -f Makefile.help
    make -f t/Makefile

Therefor each Makefile includes  t/Makefile  depending on existence of the
_SID.test  variable.


=head2 O-Saft Makefile Variable and Target Names

General rules for our variable and target names in Makefiles are:

    * names consist only of characters a-zA-Z0-9_.
    * names start with upper case letters or _
    * names starting _ are intended for internal use


=head2 O-Saft Makefile Variable Values

In general no quotes  around texts in variables  are used.  However, it is
sometimes necessary to use quotes to enforce the proper evaluation of used
variables in the text (mainly in target actions).


=head2 O-Saft:Makefile Version String

Each Makefile defines its own unique SID as variable with a version number
as value.  This SID is used  several times verbatim.  One might argue that
the variable  _SID  or  _SID.*  should be used instead for all usages. But
it is used verbatim to ensure  that exactly this string is used and cannot
be overwritten (i.e. with an environment variable) when make is called. 
If a Makefile is changed, all occurrences of the string must be changed.

The value of the  _SID* variables should be managed by the version control
system.


=head2 O-Saft Makefile Variable, Macro names

Following internal variables in each Makefile are used:

    _SID        - version in project's Makefile
    _SID.*      - version in included makefiles
    _MYSELF.*   - path of the Makefile itself (in included makefiles)

The  _SID*  variables are used to check if sub-makefiles were included.

Following general (global) variables are set in each Makefile:

    ALL.includes
    ALL.inc.type
    ALL.help.tests
    ALL.tests
    ALL.tests.log

More variables and targets are defined in following included files:

    t/Makefile
    t/Makefile.help
    t/Makefile.inc

Where  t/Makefile  may include more files.


=head2 O-Saft Makefile Variables

Following names are used, which potentially conflict with make itself:

    ECHO        - echo command
    MAKE        - make command
    MAKEFILE    - Makefile (i.g. myself, but may be redifined)

Following name prefixes are used for variables:

    SRC         - defines a source file
    GEN         - defines a genarted file
    EXE         - defines a tools to be used
    ALL         - defines summary variables
    TEST        - something related to the t/ directory
    CONTRIB     - something related to the contrib/ directory
    CRITIC      - something related to percritic targets
    HELP        - defines texts to be used in  help  and  doc  targets
    _           - names of internal (helper) variables (they are not
                  intended to be overwritten on command line)

Notes about some special variables:

    ALL.src     - list of all sources to be distributed
    ALL.tgz     - same as ALL.src but all sources prefixed with O-Saft/
    ALL.tst     - list of all sources used for testing the project
                  (ALL.tst instead of ALL.test used  to avoid conflicts
                   with ALL.tests)
    ALL.tests   - list of all targets for testing
    ALL.includes - dynamically generated list of all included Makefiles
    ALL.Makefiles - static list of all source makefiles of the project


=head1 O-Saft Makefile Annotations

As in the source code of the project,  some descriptions in makefiles also
need to be available on more than one place.  Such texts can be referenced
to using the "SEE <Annotation>" syntax in the makefiles. These annotations
are described here, one sub-section for each.


=head2 Make:target name

For better readability, "speaking names"  should be used for pattern rules
and targets. It also allows to use the special pattern rule test.pattern-%
to execute a group of similar targets.


=head2 Make:target name prefix

A  unique name prefix  for targets and pattern rules should be used in all
Makefile.* to distinguish similar names. It also allows to use the pattern
rule  test.pattern-%  to execute a group of similar targets.

Following macros should then be set only for these targets, like:

    testcmd-TEMPL%:     EXE.pl      = ../program-for.TEMPL
    testcmd-TEMPL%:     TEST.init   = +quit


=head2 Make:target matching

For collecting all targets defined in a Makefile.*, following $(shell awk)
is used:

    $(shell awk -F% '($$1 ~ /^target-/){arr[$$1]=1}$(_AWK_print_arr_END)'\
        $(_MYSELF.some-type))

(where  target-  is an example target name, and _AWK_print_arr_END  is the
awk code to print the defined array  arr[].

Target names may occour as following constructs:

    static-target:
    pattern-rule-%:
    pattern-%-rule:
    static-target:    VAR = value
    pattern-rule-%:   VAR = value

The result should contain real (static) targets only, no pattern rules.
Duplicate target names should also be avoided.

Using awk satisfies both requirements. Matching targets is as simple as:

    /^target-%/{next}              # skips pattern rules
    /^target-[^%]*:/               # matches static targets
    /^target-[^%]*:/{arr[$$1]=1}   # stores target name in an array

awk's array  arr[]  now contains all target names.  Duplicates are ignored
because the already existing  arr[target]  is overwritten. Finally we just
need to print all array elements:

    END { for (idx in arr) { print idx } }

Matching targets needs to be done individually in each Makefile*, printing
the array is always the same. Hence the code for awk's "END{}"  can be put
in a make variable also.


=head2 Make:variables and quotes

Values of variables in makefiles follow some strange rules:

  * anything right of leftmost # character is a comment and ignored
  * anything right of leftmost = character is part of the value
  * single quotes, double quotes and \ character have no special meaning
  * single quotes, double quotes and \ become meta characters depending on
    how the variable is used, in particular used with or without quotes
  * newlines in a variable are not preserved when the variable is used

For most common usage of variables, these rules are less important. But if
the variable contains descriptive texts, some care needs to be taken. This
description is about defining and using such variables with random texts.

In general it is not necessary to use quotes for variable values. However,
reading the values would be easyer and syntax highlighting in some editors
more accurate using quotes.

It is more a personal preference if quotes for variable definitions should
be used or not. The decision here is to not use quotes for definition, but
use (double) quotes for variales usage.  This also has the benefit, that a
variable is identifiable as "descriptive text" when used.

Keep in mind, that newlines to be printed must be explicitly  written in a
variable's value, $(_NL) is used for that.

GNU Make'  define  directive, which would avoid the use of  $(_NL), is not
used to set variables. May change in future ...


=head2 Make:--dry-run

When make is called with the  -n  (--dry-run) option,  make usually simply
prints the commands to be executed instead of executing them. If a command
redirects its output to a file, the file will not be generated. But if the
command is  $(MAKE)  make will be called recursively and redirected to the
specified file. This generated file then doesn't contain expected content.
Hence the generation of the file should be avoided.

The recursive make command should be printed instead of being executed.
GNU Make has following documented recipe for this:

    ifeq (n,$(findstring n,$(MAKEFLAGS)))
        @echo "$(MAKE) $(MAKEFLAGS) $* > $@"
    else
        @$(MAKE) $(MAKEFLAGS) $* > $@
    endif

Unfortunately this solution has the drawback that it

  * depends on the version of GNU Make (may work or not)
  * is not compatible with other make

Another possibility is to use shell's if-then-else syntax for the target's
commands. Beside the ugly definition of a shell inline script, this script
then also acts as one command in the target which makes the output hard to
read (by humans).

Hence following simplified  if-then-else  construct is used:

    @expr "$(MAKEFLAGS)" : n >/dev/null \
            && echo "$(MAKE) $(MFLAGS) -s $* > $@ 2>&1" \
            ||       $(MAKE) $(MFLAGS) -s $* > $@ 2>&1

Note that  $(MAKEFLAGS)  may look like:  nrR --no-print-directory


=head2 Make:Profiling

Profiling is mainly done with Perl's built-in functionality: perldebug.

There are also targets using the Perl modules  DProf and/or NYTProf  to do
the profiling.

=head3 Perl packages

  * debian: libdevel-dprof-perl libdevel-nytprof-perl


=head2 Make:profile.sub

For building the function calling tree,  perldebug (PERLDB_OPTS)  is used.
The results can be stored in a file, see  LineInfo=  options.
Unfortunately perldebug writes output to the device directly  (for example
/dev/stdout).  It is not possible to merge output from the executed script
with that of perldebug. Following options are not helpful:

  * pager=|cat
  * LineInfo=/dev/stdout
  * noTTY=1


=head2 Make:profile.sub*_%

It should be simply possible to extend the  pattern rules  with additional
arguments. For example:  profile.sub.args   and  profile.sub.args_+cn .
These arguments are extracted in the  pattern rule  itself. This avoids to
define additional conditional rules for each pattern rule to set the macro
$(TEST.args)  with the arguments.

The simplest way to split the arguments would be:

  @$(eval _args = $(shell echo "$*" | tr '_' ' '))

but the last part of the target name needs to be removed, hence following
is used for splitting:

  @$(eval _args = $(shell echo "$*" | awk -F_ '{i=1;while(i<NF){i++;print $$i}}'))

To use the default setting if no arguments are given, following is used:

  @$(eval TEST.args = $(shell [ -n "$(_args)" ] && echo $(_args) || echo $(TEST.args) ))

=head3 Make:profile.sub_%.log

Rules writing to logfiles cannot be named like  profile.sub.%.log  if they
should contain additional arguments like  profile.sub.%_+cn.log,  but must
be named  profile.sub.%.log_+cn  otherwise the  .log  extension becomes an
argument (see description how to split arguments above).


=head2 Make:profile.sub% target rule

This rule matches all targets, e.g.  profile.sub.entry, profile.sub.args .
It should also be possible to pass additional arguments to  $(DEV.pl). The
default argument is defined in  $(TEST.args). Other arguments to be passed
are simply added to the target, separated by  _  for example:

    profile.sub.args_+cn_--noheader

This is actually a shortcut for calling:

    profile.sub.args TEST.args="+cn --noheader"

The conditional rules split the additional arguments as follows:

  * split the rule's automatic variable  $*  by _
  * ignore the first value of the splitted arguments as it is part of the
    target name

=head3 Example for splitting: profile.sub.args_+cn_--noheader

    $*       : args_+cn_--noheader
    splitted : args +cn --noheader
    TEST.args:      +cn --noheader

This is done using (see above):

  awk -F_ '{i=1;while(i<NF){i++;print $$i}}'

=head3 Limitations

  * arguments with  _  itself cannot be used
  * when target names with or without additional arguments are used,  GNU
    Make's syntax requires separate conditional rules, hence there're:
        profile.sub.args:
        profile.sub.args_%:
  * miss-spelled targets fall back to the corresponding  basic conditional
    rules; for example  profile.sub.args-+cn  calls  profile.sub.args
  * if called from within  $(TEST.dir),  $(DEV.pl)  should be set on make
    call like:
       make profile.sub.args-+cn DEV.pl=../yeast.pl


=head2 Make:OSAFT_MAKE

Some data printed by the tools are  random,  means that they are different
for each call of the tool, for example date and time.
If these tools are called by make and the results are written to a logfile
which will be compared with a previous logfile, these files always differ.
To avoid this difference (because of random text) a dummy constant text is
written if our special environment variable  OSAFT_MAKE  exits.
This environment variable should be set in Makefiles.

A generic text is available as  STR_MAKEVAL  (see osaft.pm). In some cases
(i.e. for date and time) the string is prepared individually. This effects
mainly strings printed in debugging or trace mode.
To avoid dependencies to be fulfilled at runtime, STR_MAKEVAL  is not used
in all tools but hardcoded there again. This may/should change in future.


=head2 Make:generating help

Text to be printed for the  help*  targets are mainly hardcoded in various
HELP-*  macros, which will be extracted from the corresponding makefile as
needed. The advantage of this method is, that the texts are printed in the
sequence they are defined in the makefile. The disadvantage is, that other
external tools are necessary.

In some makefiles the help texts can be generated dynamically using make's
internal functions like $(foreach ...) .  It can generate  HELP-*  macros,
which then can be accessed from within make but not be extracted. Example:

    $(foreach arg,$(ARGS.program),$(eval  \
        HELP-test.$(arg) = targets for testing something) )

Therefore, the  HELP.doc  macro is used,  to which the texts will be added
dynamically, example:

    $(foreach arg, $(ARGS.program), $(eval \
        HELP.doc +=\btest.$(arg)\t\# targets for testing something)\n )

Unfortunately this adds additional leading spaces to each generated line.


=head2 EXE.pl:--trace-CLI

Most calls of  o-saft.pl  are done with the  --trace-CLI  option, which is
configured in  TEST.init  variable.  This enforces printing of the command
line at beginning of output.

For some generated output, this additional 1st line may break its intended
usage. This applies only if the output is written to a file for later use.
However, make's test targets are not intended to produce "working" output,
but logfiles to identify differences.


=head2 Troubleshooting

To parametrize targets in various ways,  they make heavy use of variables.
Some of the variables are set conditionally for targets and pattern rules.

If things go wrong, or results are unexpected, following steps may help to
narrow down the problem source:

  * use same target with  -v  appended:  test-v  instead of  test
    the executed target would then be printed; see  Makefile  for examples
    and how to set the  TRACE.target  variable; please not that for  *.log
    targets  TRACE.target.log  can also be used
  * use -n option for make
  * get list of targets, for example:  make e-ALL.test.cgi  to get list of
    executed targets for  test.cgi
  * get list of all targets (and variables), which match the specified one
    for example:  make t-test.cgi  to get list of
  * use -d option for make

=cut
