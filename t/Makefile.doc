#! /usr/bin/make -rRf
#?
#? NAME
#?      Makefile        - makefile for testing O-Saft internal documentation
#?
#? SYNOPSYS
#?      make [options] [target] [...]
#?
#? DESCRIPTION
#?      Makefile to perform testing tasks for O-Saft internal documentation.
#?
#? LIMITATIONS
#?      Requires GNU Make > 2.0.
#?
# HACKER's INFO
#       For details please see
#           ../Makefile  Makefile.help  Makefile.template
#
#? VERSION
#?      @(#) Makefile.doc 1.18 19/08/12 23:08:23
#?
#? AUTHOR
#?      19-apr-19 Achim Hoffmann
#?
# -----------------------------------------------------------------------------

_SID.doc        = 1.18

_MYSELF.doc     = t/Makefile.doc
_MY.includes   += $(_MYSELF.doc)
_MY.inc.type   += doc

first-doc-target-is-default: help.test.doc

ALL.help.test  += help.test.doc

HELP-help.test.doc  = targets for testing internal documentation and functionality
help.test.doc:        HELP_TYPE = doc
help.test.doc-v:      HELP_TYPE = doc
help.test.doc-vv:     HELP_TYPE = doc

ifeq (,$(_SID.test))
    -include t/Makefile
endif

#_____________________________________________________________________________
#________________________________________________________________ variables __|

TEST.doc.hosts      =

# need to call program here and not the one found via $PATH
EXE.o-saft          = ../$(SRC.pl)
EXE.osaft           = ../osaft.pm
EXE.osaft-standalone = ../o-saft-standalone.pl
EXE.osaft-dbx       = ../o-saft-dbx.pm
EXE.osaft-man       = ../o-saft-man.pm
EXE.osaft-usr       = ../o-saft-usr.pm
EXE.osaft-cipher    = ../OSaft/Ciphers.pm
EXE.osaft-doc-data  = ../OSaft/Doc/Data.pm
EXE.net-sslhello    = ../Net/SSLhello.pm
EXE.net-sslinfo     = ../Net/SSLinfo.pm
EXE.t-makefile      = ../t/Makefile.pod
# TODO: other tools should go to Makefile.contrib
EXE.contrib-bunt    = ../contrib/bunt.pl
EXE.contrib-openssl = ../contrib/install_openssl.sh
EXE.contrib-standalone  = ../contrib/gen_standalone.sh

# generate list of programs as variable (all EXE.* above with EXE. removed)
ARGS.program        = $(shell awk '/^EXE\./ {sub(/^EXE./,"");arr[$$1]=1}$(_AWK_print_arr_END)' $(_MYSELF.doc))

# no targets are generated for empty variables
ARGS.o-saft         =
ARGS.osaft          =
# done with ARGS.osaft-dbx:  --regex --test-regex

ARGS.osaft-cipher   = \
	description     alias   const   names   rfc     version overview \
	ciphers=dump ciphers=osaft ciphers=yeast ciphers=openssl ciphers=dumptab \
	getter=0xC0,0x2C        key=ECDHE-ECDSA-AES256-GCM-SHA384 \
	getter=0xCC,0xA9        key=ECDHE-ECDSA-CHACHA20-POLY1305-SHA256 \

ARGS.osaft-doc-data = \
	version +VERSION        list        print \
	get     get-markup      get-text    get-as-text \

# tests are functionally the same as testarg0-h--help-* from Makefile.hlp
ARGS.osaft-man      = \
	FAQ     WHY     CHECK   alias   check   cmd     commands compliance \
	content data    glossar intern  help    hint    legacy   links      \
	opt     options ourstr  pattern range   regex   rfc      text       \
	toc     todo    tools   warning exit        \
	cfg-check   cfg-data    cfg-hint    cfg-info    cfg-text cfg-regex  \
	gen-wiki    gen-html    gen-cgi     gen-pod \

ARGS.osaft-dbx      = \
	--test-show     --test-data         --test-prot --test-regex \
	--test-ciphers  --test-ciphers-list --test-ciphers-sort      \

ARGS.net-sslhello   =
ARGS.net-sslinfo    =
ARGS.t-makefile     =

ARGS.contrib-bunt       =
ARGS.contrib-openssl    =
ARGS.contrib-standalone =

HELP-_doc1          = __________________________ testing internal documentations _
HELP-test.doc       = test various internal documentation and functionality
HELP-test.doc.log   = same as test.doc but store output in '$(TEST.logdir)/'


HELP.doc = $(_NL)
HELP.test.doc.all   = # no special documentation yet

#_____________________________________________________________________________
#______________________________________________________ targets for testing __|

# The goal here is to generate all targets from the variables defined above.
# The target -pattern rule- called finally is (see t/Makefile):
#       testarg0-%:
#               cd $(TEST.dir) && $(EXE.pl) $(TEST.init) $(TEST.args)
#
# Therefore the variables  EXE.pl, TEST.dir, TEST.init and TEST.args must be
# defined properly for these targets.  In most cases, only one of  TEST.init
# or  TEST.args is needed. Means that the other can be set empty by default.
# These variables must be set depending on the target or pattern rule.
# Abstract example:
#       testarg0-osaft_%:         EXE.pl    = $(EXE.osaft)
#       testarg0-osaft_%:         TEST.args = 
#       testarg0-osaft_some-arg:  TEST.init = some-arg
#       testarg0-osaft_%:
# The first three set the required variables,  the last one ensures that the
# pattern rule  testarg0_%  is called.
#
# If a target needs special or additional settings, this is done explicitly.
#
# All programs are defined in the variable (list)  ARGS.program .
# Each of these programs should be called  with the arguments defined in the
# corresponding  ARGS.* , where  *  is any of the values from  ARGS.program
# "osaft" is such a program in the example above. With that there is:
#       EXE.osaft   = osaft.pm
#       ARGS.osaft  = some-arg
#
# Finally all generated targets are added to the variable  ALL.test.doc .
#
############################################################

ifndef doc-macros-generated
    # das ifndef erzwingt die Ausf√ºhrung der $(foreach ...) unten

    # SEE Make:generating help
    $(foreach arg, $(ARGS.program), $(eval \
	HELP.doc +=\btest.$(arg)\t\# targets for testing $(EXE.$(arg))\n\
    ))
    $(foreach arg, $(ARGS.program), $(eval \
	HELP.doc +=\btest.$(arg).log\t\# same as test.$(arg) but store output in '$(TEST.logdir)'\n\
    ))

    # arguments from ARGS.* used in the target name must not contain =
    # hence $(subst =,-,$(arg)) is used to replace = by -

    # variables test.*.all
    $(foreach prg, $(ARGS.program),\
      $(foreach arg, $(ARGS.$(prg)),$(eval \
	ALL.test.$(prg) += testarg0-$(prg)_$(subst =,-,$(arg))\
      )) \
    )

    # TEST.init for testarg0-* targets
    $(foreach prg, $(ARGS.program),\
      $(foreach arg, $(ARGS.$(prg)),$(eval \
	testarg0-$(prg)_$(subst =,-,$(arg)): TEST.init = $(arg)\
      )) \
    )
    # EXE.pl and TEST.* variables for testarg0-* targets
    $(foreach prg, $(ARGS.program), $(eval testarg0-$(prg)_%:          EXE.pl = $(EXE.$(prg))) )
    $(foreach prg, $(ARGS.program), $(eval testarg0-$(prg)_%:       TEST.args = ) )
    $(foreach prg, $(ARGS.program), $(eval testarg0-$(prg)_pod:        EXE.pl = perldoc ) )
    $(foreach prg, $(ARGS.program), $(eval testarg0-$(prg)_pod:     TEST.init = $(EXE.$(prg)) ) )
    $(foreach prg, $(ARGS.program), $(eval testarg0-$(prg)_--help:  TEST.init = --help ) )

endif

# OSaft/Doc/Data.pm function needs a file where to read the information
# it's found automatically when using o-saft.pl but not OSaft/Doc/Data.pm
testarg0-osaft-doc-data_%:  TEST.args = help.txt
testarg0-osaft-dbx_%:          EXE.pl = $(EXE.o-saft)

# targets: EXE.* --help
ALL.test.prog.help  = $(foreach prg, $(ARGS.program), testarg0-$(prg)_--help )
$(ALL.test.prog.help):

# targets: EXE.pl = perlpod
ALL.test.prog.pod   = $(foreach prg, $(ARGS.program), testarg0-$(prg)_pod )
$(ALL.test.prog.pod):

# generate pattern rules, one foreach EXE.*
$(foreach prg, $(ARGS.program), testarg0-$(prg)_% ):
# generate summary rules, one foreach EXE.*
$(foreach prg, $(ARGS.program), $(eval test.$(prg).all: $(ALL.test.$(prg))) )

ALL.test.doc    = $(foreach prg, $(ARGS.program),\
			$(foreach arg, $(ARGS.$(prg)), testarg0-$(prg)_$(subst =,-,$(arg)))\
		   )
ALL.test.doc   += $(ALL.test.prog.help) $(ALL.test.prog.pod)
ALL.test.doc.log    = $(ALL.test.doc:%=%.log) test.log-compare-hint

test.doc.log-compare:   TEST.target_prefix  = testarg0-doc
test.doc.log-move:      TEST.target_prefix  = testarg0-doc
test.doc.log:           TEST.target_prefix  = testarg0-doc


test.doc.all:       $(ALL.test.doc)
test.doc.all.log:   $(ALL.test.doc.log)
test.doc.log:       $(ALL.test.doc.log)
test.doc:           test.doc.all

#_____________________________________________________________________________
#_____________________________________________________________________ test __|

# feed main Makefile
ALL.tests      += $(ALL.test.doc)
ALL.tests.log  += $(ALL.test.doc.log)

